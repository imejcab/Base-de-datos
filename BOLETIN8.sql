-Ejercicio 1
/*Crear un trigger sobre la tabla EMPLEADOS para que no se permita que un empleado
sea jefe de más de cinco empleados*/
CREATE TABLE empleados
(dni VARCHAR2(9) PRIMARY KEY,
nomemp VARCHAR2(50),
jefe VARCHAR2(9),
departamento NUMBER,
salario NUMBER(9,2) DEFAULT 1000,
usuario VARCHAR2(50),
fecha DATE
);
CONSTRAINT FK_JEFE FOREIGN KEY (jefe) REFERENCES empleados (dni) );
INSERT INTO EMPLEADOS VALUES('27589456X','LUIS', NULL, 122, 2000,'LUISFONT' ,TO_DATE('02/11/1998', 'DD/MM/YYYY'));
INSERT INTO EMPLEADOS VALUES('27483336X','LUISA','27589456X', 122, 1300,'LUISAJON' ,TO_DATE('02/12/1998', 'DD/MM/YYYY'));
INSERT INTO EMPLEADOS VALUES('27513336X','LUISA','27589456X', 122, 1300,'LUISAJON' ,TO_DATE('02/12/1998', 'DD/MM/YYYY'));
INSERT INTO EMPLEADOS VALUES('37583336X','LUISA','27589456X', 122, 1300,'LUISAJON' ,TO_DATE('02/12/1998', 'DD/MM/YYYY'));
INSERT INTO EMPLEADOS VALUES('27583736X','LUISA','27589456X', 122, 1300,'LUISAJON' ,TO_DATE('02/12/1998', 'DD/MM/YYYY'));
INSERT INTO EMPLEADOS VALUES('27593336X','LUISA','27589456X', 122, 1300,'LUISAJON' ,TO_DATE('02/12/1998', 'DD/MM/YYYY'));
INSERT INTO EMPLEADOS VALUES('27583338X','LUISA','27589456X', 122, 1300,'LUISAJON' ,TO_DATE('02/12/1998', 'DD/MM/YYYY'));
INSERT INTO EMPLEADOS VALUES('27583338X','LUISA','27589450X', 122, 1300,'LUISAJON' ,TO_DATE('02/12/1998', 'DD/MM/YYYY'));
INSERT INTO EMPLEADOS VALUES('20583338X','LUISA','27589450X', 122, 1300,'LUISAJON' ,TO_DATE('02/12/1998', 'DD/MM/YYYY'));
INSERT INTO EMPLEADOS VALUES('20003338X','LUISA','27589450X', 122, 1300,'LUISAJON' ,TO_DATE('02/12/1998', 'DD/MM/YYYY'));
INSERT INTO EMPLEADOS VALUES('20003138X','LUISA','27589450X', 122, 1300,'LUISAJON' ,TO_DATE('02/12/1998', 'DD/MM/YYYY'));
CREATE OR REPLACE 
TRIGGER GESTIONARJEFE 
	BEFORE INSERT ON EMPLEADOS 
	FOR EACH ROW
DECLARE 
CONTADOR NUMBER (3);
BEGIN 
	CONTADOR:=0;
	SELECT COUNT(E.DNI)
	INTO CONTADOR
	FROM EMPLEADOS E
	WHERE E.JEFE LIKE :NEW.JEFE;
	IF CONTADOR >5 THEN
		RAISE_APPLICATION_ERROR(-20005,'NO SE PUEDEN INSERTAR MAS DE 5 EMPLEADOS PARA UN MISMO JEFE');
	END IF;
END GESTIONARJEFE;
/*Crear un trigger para impedir que se aumente el salario de un empleado en más de un
20%.*/
CREATE OR REPLACE
TRIGGER LIMITESUBIDASALARIO
	BEFORE UPDATE OF SALARIO ON EMPLEADOS
	FOR EACH ROW 
	DECLARE
	SALARIONOVALIDO EXCEPTION;
	BEGIN
		IF (:NEW.SALARIO/:OLD.SALARIO)> 1.2 THEN
			RAISE SALARIONOVALIDO;
		ELSE IF;
		COMMIT;
		EXCEPTION
		WHEN SALARIONOVALIDO THEN
			DBMS_OUTPUT.PUT_LINE('EL NUEVO SALARIO NO ES VALIDO PORQUE SUPERA EL INCREMENTO DEL 20%');
			ROLLBACK;
	END LIMITESUBIDASALARIO;
UPDATE EMPLEADOS SET SALAR=2000 WHERE SALAR=1300;
/*CREATE OR REPLACE 
	TRIGGER IMP_SUB_SALAR_MAS_20
	BEFORE UPDATE OF SALARIO ON EMPLEADOS 
	FOR EACH ROW
	
BEGIN 
	IF :NEW.SALARIO > :OLD.SALARIO* 1.20 THEN 
		RAISE_APPLICATION_ERROR(-20002,'Error no se puede subir el salrio a más de un 20% del salario anterior.');
	END IF;
	
END IMP_SUB_SALAR_MAS_20;*/
/*Crear una tabla empleados_baja con la siguiente estructura:
Crear un trigger que inserte una fila en la tabla empleados_baja cuando se borre una fila
en la tabla empleados. Los datos que se insertan son los del empleado que se da de baja
en la tabla empleados, salvo en las columnas usuario y fecha se grabarán las variables
del sistema USER y SYSDATE que almacenan el usuario y fecha actual*/
CREATE TABLE empleados_baja
( dni VARCHAR2(9) PRIMARY KEY,
nomemp VARCHAR2 (50),
jefe VARCHAR2(9),
departamento NUMBER,
salario NUMBER(9,2) DEFAULT 1000,
usuario VARCHAR2(50),
fecha DATE );
/*CREATE OR REPLACE 
TRIGGER EMPLEADOBAJA 
	AFTER DELETE ON EMPLEADOS
	BEGIN
		INSERT INTO EMPLEADOS_BAJA 
		VALUES (:OLD.DNI, :OLD.NOMEMP, :OLD.JEFE, :OLD.DEPARTAMENTO, :OLD.SALARIO, USER, SYSDATE);
	END EMPLEADOBAJA;*/
CREATE OR REPLACE 
	TRIGGER BAJA_EMPLEADO
	AFTER DELETE ON EMPLEADOS
	FOR EACH ROW 
	
BEGIN 
	
	INSERT INTO empleados_baja VALUES (:OLD.dni,:OLD.nomemp,:OLD.jefe,:OLD.departamento,:OLD.salario, TO_CHAR(USER), SYSDATE);
	
END BAJA_EMPLEADO;
DELETE FROM EMPLEADOS WHERE DNI LIKE '27593336X';
/*Crear un trigger para impedir que, al insertar un empleado, el empleado y su jefe puedan
pertenecer a departamentos distintos. Es decir, el jefe y el empleado deben pertenecer al
mismo departamento*/
CREATE OR REPLACE
TRIGGER SAMEDEPARTAMENTO
	BEFORE INSERT ON EMPLEADOS
	FOR EACH ROW
	BEGIN
		SELECT E.DEPARTAMENTO
		INTO EMPLEADODEPART
		FROM EMPLEADOS E
		WHERE E.DNI=:NEW.JEFE;
		IF EMPLEADODEPART <> :NEW.DEPARTAMENTO THEN
			RAISE ERRORDEPARTAMENTO;
		END IF;
		COMMIT;
		EXCEPTION 
		WHEN ERRORDEPARTAMENTO THEN
			DBMS_OUTPUT.PUT_LINE('EL EMPLEADO Y JEFE DEBEN PERTENECER AL MISMO DEPARTAMENTO');
			ROLLBACK;
	END SAMEDEPARTAMENTO;
/*Crear un trigger para impedir que, al insertar un empleado, la suma de los salarios de los
empleados pertenecientes al departamento del empleado insertado supere los 10.000
euros*/
CREATE OR REPLACE
TRIGGER TOPESUMASALARIAL
	BEFORE INSERT ON EMPLEADOS
	FOR EACH ROW
	DECLARE
	SUMASALARIAL EMPLEADOS.SALARIO%TYPE;
	LIMITESUPERADO EXCEPTION;
	BEGIN
		SELECT SUM(E.SALARIO)
		INTO SUMASALARIAL
		FROM EMPLEADOS E;
		IF SUMASALARIAL+ :NEW.SALARIO >10000 THEN
			RAISE LIMITESUPERADO;
		END IF;
		COMMIT;
		EXCEPTION
		WHEN LIMITESUPERADO THEN
			DBMS_OUTPUT.PUT_LINE('NO PODEMOS SUPERAR 10000 EUROS DE SUMA SALARIAL');
			ROLLBACK;
	END TOPESUMASALARIAL;
/*Crea la tabla:
Creamos un trigger que se active cuando modificamos algún campo de "empleados" y
almacene en "controlCambios" el nombre del usuario que realiza la actualización, la
fecha, el tipo de operación que se realiza, el dato que se cambia y el nuevo valor.*/
CREATE TABLE controlCambios(
 usuario varchar2(30),
 fecha date,
 tipooperacion varchar2(30),
 datoanterior varchar2(30),
 datonuevo varchar2(30)
);
CREATE OR REPLACE
TRIGGER CONTROLEMPLEADOS
	AFTER UPDATE ON EMPLEADOS
	FOR EACH ROW
	DECLARE
	INFO EMPLEADOS%ROWTYPE;
	BEGIN
		SELECT *
		INTO INFO
		FROM EMPLEADO E
		WHERE E.USUARIO=:NEW.USUARIO;
		IF :OLD.DNI!=:NEW.DNI THEN
			INSERT INTO CONTROLCAMBIOS VALUES (USER, TO CHAR(SYSDATE, 'DD/MM/YYYY HH:MI:SS'),' ACTUALIZACION ', TO CHAR(:OLD.DNI), TO CHAR(:NEW.DNI));
		END IF;
		IF :OLD.NOMENP!=:NEW.NOMENP THEN
			INSERT INTO CONTROLCAMBIOS VALUES (USER, TO CHAR(SYSDATE, 'DD/MM/YYYY HH:MI:SS'),' ACTUALIZACION ', TO CHAR(:OLD.NOMENP), TO CHAR(:NEW.NOMENP));
		END IF;
		IF :OLD.JEFE!=:NEW.JEFE THEN
			INSERT INTO CONTROLCAMBIOS VALUES (USER, TO CHAR(SYSDATE, 'DD/MM/YYYY HH:MI:SS'),' ACTUALIZACION ', TO CHAR(:OLD.JEFE), TO CHAR(:NEW.JEFE));
		END IF;
		IF :OLD.DEPARTAMENTO!=:NEW.DEPARTAMENTO THEN
			INSERT INTO CONTROLCAMBIOS VALUES (USER, TO CHAR(SYSDATE, 'DD/MM/YYYY HH:MI:SS'),' ACTUALIZACION ', TO CHAR(:OLD.DEPARTAMENTO), TO CHAR(:NEW.DEPARTAMENTO));
		END IF;
		IF :OLD.SALARIO!=:NEW.SALARIO THEN
			INSERT INTO CONTROLCAMBIOS VALUES (USER, TO CHAR(SYSDATE, 'DD/MM/YYYY HH:MI:SS'),' ACTUALIZACION ', TO CHAR(:OLD.SALARIO), TO CHAR(:NEW.SALARIO));
		END IF;
	END CONTROLEMPLEADOS;
	UPDATE INTO EMPLEADOS SET SALARIO=1400 WHERE SALARIO=1600;
/*Creamos otro trigger que se active cuando ingresamos un nuevo registro en "empleados",
debe almacenar en "controlCambios" el nombre del usuario que realiza el ingreso, la
fecha, el tipo de operación que se realiza , "null" en "datoanterior" (porque se dispara con
una inserción) y en "datonuevo" el valor del nuevo dato.*/
CREATE OR REPLACE
TRIGGER ALTAEMPLEADO
	AFTER INSERT ON EMPLEADOS
	FOR EACH ROW
	DECLARE
	CONTROLINSERT EMPLEADOS%ROWTYPE;
	BEGIN
		SELECT *
		INTO CONTROLINSERT
		FROM EMPLEADOS E
		WHERE E.USUARIO=:NEW.USUARIO;
		IF CONTROLINSERT.DNI IS NOT NULL THEN
			INSERT INTO CONTROLCAMBIOS VALUES (USER, TO CHAR(SYSDATE, 'DD/MM/YYYY HH:MI:SS'),' INSERTAR EMPLEADO ', NULL, TO CHAR(:NEW.DNI));
		END IF;
		IF CONTROLINSERT.NOMENP IS NOT NULL THEN
			INSERT INTO CONTROLCAMBIOS VALUES (USER, TO CHAR(SYSDATE, 'DD/MM/YYYY HH:MI:SS'),' INSERTAR EMPLEADO ', NULL, TO CHAR(:NEW.NOMENP));
		END IF;
		IF CONTROLINSERT.JEFE IS NOT NULL THEN
			INSERT INTO CONTROLCAMBIOS VALUES (USER, TO CHAR(SYSDATE, 'DD/MM/YYYY HH:MI:SS'),' INSERTAR EMPLEADO ', NULL, TO CHAR(:NEW.JEFE));
		END IF;
		IF CONTROLINSERT.DEPARTAMENTO IS NOT NULL THEN
			INSERT INTO CONTROLCAMBIOS VALUES (USER, TO CHAR(SYSDATE, 'DD/MM/YYYY HH:MI:SS'),' INSERTAR EMPLEADO ', NULL, TO CHAR(:NEW.DEPARTAMENTO));
		END IF;
		IF CONTROLINSERT.SALARIO IS NOT NULL THEN
			INSERT INTO CONTROLCAMBIOS VALUES (USER, TO CHAR(SYSDATE, 'DD/MM/YYYY HH:MI:SS'),' INSERTAR EMPLEADO ', NULL, TO CHAR(:NEW.SALARIO));
		END IF;
	END ALTAEMPLEADO;
/*Crea un trigger que al actualizar la columna fechaentrega de pedidos la compare con la
fechaesperada.
• Si fechaentrega es menor que fechaesperada añadirá a los comentarios 'Pedido
entregado antes de lo esperado'.
• Si fechaentrega es mayor que fechaesperada añadir a los comentarios 'Pedido
entregado con retraso'.*/
CREATE TABLE pedidos
 ( CODIGOPEDIDO NUMBER,
FECHAPEDIDO DATE,
FECHAESPERADA DATE,
FECHAENTREGA DATE DEFAULT NULL,
ESTADO VARCHAR2(15),
COMENTARIOS CLOB,
CODIGOCLIENTE NUMBER
 )
--Inserta los siguientes registros:
Insert into PEDIDOS
(CODIGOPEDIDO,FECHAPEDIDO,FECHAESPERADA,FECHAENTREGA,ESTADO,CODIGOCLIENTE)
values
(1,to_date('17/01/06','DD/MM/YY'),to_date('19/01/06','DD/MM/YY'),to_date('19/0
1/06','DD/MM/YY'),'Entregado',5);
Insert into PEDIDOS
(CODIGOPEDIDO,FECHAPEDIDO,FECHAESPERADA,FECHAENTREGA,ESTADO,CODIGOCLIENTE)
values
(2,to_date('23/10/07','DD/MM/YY'),to_date('28/10/07','DD/MM/YY'),to_date('26/1
0/07','DD/MM/YY'),'Entregado',5);
Insert into PEDIDOS
(CODIGOPEDIDO,FECHAPEDIDO,FECHAESPERADA,FECHAENTREGA,ESTADO,CODIGOCLIENTE)
values
(3,to_date('20/06/08','DD/MM/YY'),to_date('25/06/08','DD/MM/YY'),null,'Rechaza
do',5);
Insert into PEDIDOS
(CODIGOPEDIDO,FECHAPEDIDO,FECHAESPERADA,FECHAENTREGA,ESTADO,CODIGOCLIENTE)
values
(4,to_date('20/01/09','DD/MM/YY'),to_date('26/01/09','DD/MM/YY'),null,'Pendien
te',5);
CREATE OR REPLACE
TRIGGER FECHAENTREGAACTUALIZADA
	AFTER UPDATE OF FECHAENTREGA ON PEDIDOS
	FOR EACH ROW
	DECLARE
	ENTREGA DATE;
	ESPEROENTREGA DATE;
	COMENTAR CLOB;
	BEGIN
		SELECT E.FECHAENTREGA, E.FECHAESPERADA, E.COMENTARIOS
		INTO ENTREGA, ESPEROENTREGA, COMENTAR
		FROM EMPLEADOS E
		WHERE E.CODIGOPEDIDO=:NEW.CODIGOPEDIDO;
		IF :NEW.ENTREGA > :OLD.ESPEROENTREGA THEN
			UPDATE PEDIDOS SET COMENTARIOS=TO CHAR(COMENTAR || 'Pedido
			entregado despues de lo esperado') WHERE COMENTAR=:OLD.COMENTARIO;
		END IF;
		IF :NEW.ENTREGA < :OLD.ESPEROENTREGA THEN
			UPDATE PEDIDOS SET COMENTARIOS=TO CHAR(COMENTAR || 'Pedido
			entregado antes de lo esperado') WHERE COMENTAR=:OLD.COMENTARIO;
		END IF;
	END FECHAENTREGAACTUALIZADA;
/*CREATE OR REPLACE TRIGGER EJERCICIO8
    AFTER UPDATE OF FECHAENTREGA ON PEDIDOS
    FOR EACH ROW
DECLARE 
    COM CLOB;
BEGIN
    IF(:NEW.FECHAENTREGA < :OLD.FECHAESPERADA) THEN
        COM:='PEDIDO ENTREGADO ANTES DE LO ESPERADO';
    ELSIF (:NEW.FECHAENTREGA > :OLD.FECHAESPERADA) THEN
        COM:='PEDIDO ENTREGADO CON RETRASO';
    END IF;
    UPDATE PEDIDOS
    SET COMENTARIOS=COM
    WHERE CODIGOPEDIDO =:OLD.CODIGOPEDIDO;
END;*/
/*Modifica el trigger anterior pero solo se ejecute si fechaentrega es mayor que
fechaesperada*/
CREATE OR REPLACE
TRIGGER FECHAENTREGATARDE
	AFTER UPDATE OF FECHAENTREGA ON PEDIDOS
	FOR EACH ROW 
	WHEN (:NEW.FECHAENTREGA > :OLD.FECHAESPERADA)
	DECLARE
	ENTREGA DATE;
	ESPEROENTREGA DATE;
	COMENTAR CLOB;
	BEGIN
		SELECT E.FECHAENTREGA, E.FECHAESPERADA, E.COMENTARIOS
		INTO ENTREGA, ESPEROENTREGA, COMENTAR
		FROM EMPLEADOS E
		WHERE E.CODIGOPEDIDO=:NEW.CODIGOPEDIDO;
		IF ENTREGA > ESPEROENTREGA THEN
			UPDATE PEDIDOS SET COMENTARIOS=TO CHAR(COMENTAR || 'Pedido
			entregado despues de lo esperado') WHERE COMENTAR=:OLD.COMENTARIO;
		END IF;
	END FECHAENTREGATARDE;
